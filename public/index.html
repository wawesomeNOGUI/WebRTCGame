<!DOCTYPE html>

<html>

<!--
Golang base64 Session Description: <textarea id="remoteSessionDescription"></textarea> <br/>
<button onclick="window.startSession()"> Start Session </button> <br />
Browser base64 Session Description <textarea id="localSessionDescription" readonly="true"></textarea> <br />
-->
<br />

Message: <textarea id="message">This is my DataChannel message!</textarea> <br/>
<button onclick="window.sendMessage()"> Send Message </button> <br />

<div id="logs"></div>

<script>

//=======================Global DataChannel Vars================================
var UDPChan;
var TCPChan;
//==============================================================================



let log = msg => {
  document.getElementById('logs').innerHTML += msg + '<br>'
}

var ws;


window.addEventListener("load", function(evt) {
  ws = new WebSocket("ws://162.200.58.171:80/echo");  //address to connect to, /echo triggers go echo function

  ws.onopen = function(evt) {
      console.log("OPEN");
  }
  ws.onclose = function(evt) {
      console.log("CLOSE");
      ws = null;
  }
  ws.onmessage = function(evt) {
      console.log("RESPONSE: " + evt.data);
      //we're expecting the first websocket message to be the server's SDP
      //so we'll go ahead and start the WEBRTC session with that SDP
      window.startSession(evt.data)
  }
  ws.onerror = function(evt) {
      console.log("ERROR: " + evt.data);
  }

//=====================WEBRTC===========================

  const pc = new RTCPeerConnection({
    iceServers: [
      {
        urls: 'stun:stun.l.google.com:19302'
      }
    ]
  })


  var sends = 0;

  pc.onsignalingstatechange = e => log(pc.signalingState)
  pc.oniceconnectionstatechange = e => log(pc.iceConnectionState)
  pc.onicecandidate = event => {
    if(sends == 0){
      //Send the original SDP, we'll send additional ice candidates from the
      //onicecandidate event handler (trickle ICE)
      ws.send( btoa(JSON.stringify(pc.localDescription)) )
      console.log(pc.LocalDescription)

      sends = 1
    }
    //console.log(event.candidate)
    ws.send(JSON.stringify(event.candidate))
  }



  var previousData = 0;
  var numMessages = 0;

  function howManyMessages(){
    console.log(numMessages + " Messages Received");
  }

  setInterval(howManyMessages, 10000);

  pc.ondatachannel = e => {

        if(e.channel.label == "UDP"){
          UDPChan = e.channel;
          log('New DataChannel ' + UDPChan.label);
          log("Ordered: " + UDPChan.ordered);
          log("MaxRetransmits: " + UDPChan.maxRetransmits);
          log("\n");
          UDPChan.onclose = () => console.log(UDPChan.label + ' has closed');
          UDPChan.onopen = () => console.log(UDPChan.label + ' has opened');

          UDPChan.onmessage = function(e){
              numMessages++;
              //log(`Message from DataChannel '${UDPChan.label}' payload '${e.data}'`)
              if(e.data - previousData != 1){
                log("Unordered or lostData!")
                log(previousData)
                log(e.data)
              }
              previousData = e.data;
          }

        }else if(e.channel.label == "TCP"){
          TCPChan = e.channel;
          log('New DataChannel ' + TCPChan.label);
          log("Ordered: " + TCPChan.ordered);
          log("MaxRetransmits: " + TCPChan.maxRetransmits);
          log("\n");
          TCPChan.onclose = () => console.log(TCPChan.label + ' has closed');
          TCPChan.onopen = () => console.log(TCPChan.label + ' has opened');
          TCPChan.onmessage = function(e){};

          window.sendMessage = () => {
            let message = document.getElementById('message').value
            if (message === '') {
              return alert('Message must not be empty')
            }

            TCPChan.send(message)
          }
        }


  }



  window.startSession = (e) => {
    let sd = e;
    if (sd === '') {
      return alert('Session Description must not be empty')
    }

    pc.setRemoteDescription(new RTCSessionDescription(JSON.parse(atob(sd)))).catch(log)
    console.log("Pog")
    pc.createAnswer().then(d => pc.setLocalDescription(d)).catch(log)

  }

})



</script>

</html>
